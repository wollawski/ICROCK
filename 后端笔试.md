# 后端面试

## 一、非技术题目
### 1.技术经历
大一的学习了C++、数据结构、数据库，最近在看《Java核心技术》。
### 2.学习路线
简单看了《HTTP权威指南》、了解了一点前后端的基础知识，以及跟着[菜鸟](https://www.runoob.com/go/go-map.html)学习了Golang的基础语法。
### 3.互联网
根据我对家里亲戚朋友，学长学姐的了解，我觉得目前来说互联网还是整体向好发展，大模型提出来之后，各个公司也都有自己的大模型开发，因此我认为岗位也在不断在被创造出来。
我认为华中大体育客户端有很大的优化必要，比如其在后台不刷新，不支持其他软件导入数据、不支持手表软件等。
### 4.规划
目前想以就业为主要导向，学无止境的话不如一边工作一边学习。
### 5.其他技术类社团
没有。


---

## 二、计算机基础

### 1.二叉树排序

**先序遍历：**冰 岩 后 端 组 很 酷 不 是 吗
**中序遍历：**组 端 很 后 酷 岩 冰 是 吗 不
**后序遍历：**组 很 端 酷 后 岩 吗 是 不 冰
完整代码请见：[二叉树排序](https://github.com/wollawski/ICROCK/tree/main/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E4%BA%8C%E5%8F%89%E6%A0%91)

### 2.后端漏洞

**方法：**
我对后端没有了解，因此我像ds询问包括“什么是form-data”以及“flask run --和--debug的区别”这些问题。

在了解form-data结构时，我观察到它的结构中包含一个由浏览器随机生成的用于分割各个部分的 boundary 字符串，而我知道所谓随机大多是伪随机，因此我认为这里可能存在漏洞，在经过搜索后，以下链接证实了我的猜测：[form-data爆嚴重漏洞](https://www.technice.com.tw/techmanage/infosecurity/183979/ )

**解决方法：**

1. 使用其他加密级随机数生成器。
2. 为 filename 设置禁用字段。

### 3.整数溢出

1. `a = -1; b = 0; c = INT_MAX；`
2. int为32位，因此能表示的最大整数是2^31-1。超出这个范围会溢出，而计算c-a时就溢出了。
3. 将 cmp 函数改成如下：

```C++
int cmp_safe(const void *pa, const void *pb) {
    const int a = *(const int *)pa;
    const int b = *(const int *)pb;
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
}
```

完整代码请见：[整数溢出](https://github.com/wollawski/ICROCK/blob/main/2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3.%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/3.%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0.cpp)

### 4.HTTP

**常用方法**
GET:通常用于请求服务器发送某个资源。
HEAD:方法与 GET 方法的行为很类似，但服务器在响应中只返回HTTP首部。不会返回实体的主体部分。
PUT:与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。
POST:用来向服务器输入数据的。POST 用于向服务器发送数据。PUT 用于向服务器上的资源（例如文件）中存储数据。
TRACE:用于验证请求是否如愿穿过了请求 / 响应链，也可以用来查看代理和其他应用程序对用户请求所产生效果。
OPTIONS:请求 Web 服务器告知其支持的各种方法、功能。
DELETE:删除请求 URL 所指定的资源。
**HTTP状态码**
100～199：信息性状态码
100 Continue：说明收到了请求的初始部分，请客户端继续。
101 Switching Protocols：说明服务器正在根据客户端的指定，将协议切换成 Update 首部所列的协议。
200～299：成功状态码
服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。
300～399：重定向状态码
表示需要客户端采取进一步的操作才能完成请求。
400～499：客户端错误状态码
用于告知客户端它的请求无法被完成。
500～599：服务器错误状态码
表示服务器出错。

### 5.橙子的烦恼

因为删除的API也是GET类型，而GET是用于向服务器请求获取数据的方法，因此可能在他人访问时也触发了删除的指令。

### 6.橙子的烦恼2

我对网络没有了解，因此通过一番搜索学习了以下内容：
[前后端如何通信](https://blog.csdn.net/m0_57344393/article/details/136084795)
[什么是API](https://blog.csdn.net/API_Json/article/details/133087360)、[什么是API2](https://zhuanlan.zhihu.com/p/347125981)
[博客园：RESTful API设计精髓](https://www.cnblogs.com/fishblog/articles/18801451)、[CSDN：深入解析 RESTful API](https://blog.csdn.net/mng123/article/details/146473344)、[菜鸟：REST API 教程](https://www.runoob.com/w3cnote/rest-api-tutorial.html)、[阿里云：RESTful API 接口设计规范](https://developer.aliyun.com/article/940518)
后几个关于REST API的文档内容差的不大，在了解基本结构后，重点放在各个文档对于其安全性描述，以完成题目要求。
注意到对于安全性要求包括：身份认证、数据加密、输入的验证与过滤、限流和防爬。
之后的搜索方向集中于REST API 漏洞，以下是我找到的比较有用的文章：
[阿里云：API 接口渗透测试](https://xz.aliyun.com/news/2094)、[阿里云：一个请求参数 打穿Rest API](https://xz.aliyun.com/news/11621#toc-4))、[博客园：黑盒视角下的RESTful API安全测试](https://www.cnblogs.com/smileleooo/p/18384083)、[RESTful API 安全漏洞分析及防范](https://www.javascriptcn.com/post/67d5c9c4a941bf7134b076d8)
总结之后有以下几种方式能够实现：

身份认证类：身份认证机制如果设计的不合理，或者被错误地实施，那么攻击者就可以破坏认证令牌或利用实现缺陷来暂时或永久地冒充其他用户的身份。

数据加密类：由于RESTful API更加结构化的设计，使得可以容易的预测访问API的方式（如将HTTP方法从GET替换为PUT），此类缺陷允许攻击者访问未授权的功能。

限流和防爬类：一些查询相关信息的接口，如果未对接口进行查询次数控制，则会导致大量信息泄露。另一方面如果频繁频繁恶意进行接口调用查询（DOS攻击）。

输入的验证与过滤类：如[链接](https://xz.aliyun.com/news/11621#toc-4)就利用了请求的变量覆盖了系统的变量实现了管理员信息的查询。

预防措施：

1. 永远不要信任用户输入数据，对所有输入参数进行校验和过滤。
2. 使用预编译语句或存储过程执行 SQL 查询操作，防止拼接 SQL 语句。
3. 限制用户账号或角色在数据库中的操作权限。
4. 对所有 API 操作进行身份验证。

#### 7.短信轰炸

根据第六题所获得的信息，猜想有以下几种方法：

1. 严格验证短信发送的用户信息，如果是非法用户则选择屏蔽。
2. 限制同一个接口一段时间内的信息流量，保证一个接口不会被非常规过度调用。
3. 部署本地的短信内容比较机制，在不泄露用户隐私的情况下判断垃圾短信。

---

## 三、Golang

### 1.AD

### 2.B

### 3.

### 4.切片

`a==nil`结果是true，a切片被声明但没有初始化，因此将被赋零值，切片的零值是nil
`b==nil`结果是false，b切片使用短声明并且被初始化，尽管长度和容量都为 0，但指针指向一个有效的内存位置。
`c==nil`结果是false，与b切片一致。

### 5.轮流运行

```
package main

import (
	"fmt"
	"math/rand"
	"time"
)

var someNumber int

func main() {
	someNumber = 0
	totalIterations := 0

	turnA := make(chan bool, 1)
	turnB := make(chan bool, 1)

	turnB <- true

	go func() {
		for {
			<-turnA
			someNumber -= 1
			fmt.Println("someNumber =", someNumber)

			if someNumber >= 100 {
				fmt.Println("Total iterations: ", totalIterations)
				break
			}

			turnB <- true
			time.Sleep(3 * time.Millisecond)
		}
	}()

	go func() {
		for {
			<-turnB
			someNumber += 2
			totalIterations += 1
			//fmt.Println("someNumber =", someNumber)
			time.Sleep(time.Duration(rand.Intn(5)) * time.Millisecond)

			turnA <- true
		}
	}()

	time.Sleep(10 * time.Second)
}

```

具体代码请见：[轮换执行](https://github.com/wollawski/ICROCK/blob/main/3Golong/5.go)

---

## 四、其他语言

### 1.C/CXX

**区别：**C语言是面向过程语言，而C++是面向对象语言
我认为那样的说法并不正确，因为从C到C++最大的变化是引入了面对对象的编程。

### 8.python GIL

“全局解释锁”（GIL）是 CPython 解释器（Python 语言最主流实现）中使用的一种互斥锁（mutex），它规定在任何时刻，只有一个线程可以执行 Python 字节码。

---

## 五、操作系统/计⽹/数据库等
### 1.Socket
### 2.client/server
Client：Web浏览器
Server：百度公司的Web服务器

非持续性连接过程：
1. 客户端进程在默认端口号发起一个到服务器www.baidu.com 的TCP连接，在客户和服务器上分别有一个套接字与该连接相关联 。
2. 客户经它的套接字向该服务器发送一个 HTTP 请求报文。
3. HTTP 服务器进程经它的套接字接收该请求报文，从其存储器 (RAM 或磁盘）中 检索出被请求对象, 在一个 HTTP 响应报文中封装对象，并通过其套接字向客户发送响应报文 。
4. HTTP 服务器进程通知 TCP 断开该TCP连接。（但是直到 TCP 确认客户已经 完整 地收到响应报文为止，它才会实际中断连接 。）
5. HTTP 客户接收响应报文， TCP 连接关闭。
6. 客户从响应报文中提取出该请求对象，并用户解释该页面。

### 3.TCP/UDP
同：
- TCP、UDP的服务器在客户试图发起接触前都必须作为进程运行起来。
- 都是传输层协议。
- 都使用端口号来标识同一台主机上的不同应用程序。

异：

|                    |                        TCP                         |                    UDP                     |
| :----------------: | :------------------------------------------------: | :----------------------------------------: |
|       连接性       | 面向连接的协议，通信前必须通过三次握手建立稳定连接 | 无连接的协议，无需建立连接，可直接发送数据 |
|       可靠性       |               TCP确保数据的可靠传输                |        UDP不提供数据包的可靠性保障         |
| 流量控制与拥塞控制 |                         有                         |                     无                     |
|    数据传输顺序    |                  数据包按顺序到达                  |           不保证数据包按顺序到达           |
|      应用场景      |                      电子邮件                      |                  语音通话                  |


### 7.SQL
```sql
SELECT u.id, u.name
FROM Users u
WHERE NOT EXISTS (
    SELECT p.id
    FROM (
        SELECT passageId as id
        FROM Likes
        GROUP BY passageId
        ORDER BY COUNT(*) DESC
        LIMIT 10
    ) p
    WHERE NOT EXISTS (
        SELECT 1
        FROM Likes l
        WHERE l.passageId = p.id AND l.userId = u.id
    )
);

```

以下是拓展题b部分实现：

```sql
# 以下可以返回用户的id以及其点赞的文章的平均点赞数。
SELECT userId, AVG(sum_count)
FROM likes JOIN 
(SELECT passageId, COUNT(*) AS sum_count
FROM likes
GROUP BY passageId）likes_sum 
ON likes.userId = likes_sum.userId
GROUP BY userId;
```

---

## 七、趣题
### 1.压缩机
尝试逆向看看是否能以100：1的比例放大回去。
在通过同样的方式使自己再次经历1：100的压缩，缩小到足够小以在搅拌机的缝隙中存活。










---